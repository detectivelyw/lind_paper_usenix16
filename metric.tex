\section{Developing and Assessing a Quantitative Evaluation Metric for Kernel Security}
\label{sec.metric}

%The first step to addressing the threat articulated above is to establish metric
%by which kernel security can be quantitatively evaluated. In this section
%we document the development of such a metric.
%First, we look at current commonly used metrics for code complexity and why they may be less than effective.
%The next section discusses our proposed metric, which focuses on using the kernel code paths accessed by widely used applications.
%Finally, we use the metric to verify our central hypothesis, by testing for the presence of 40 severe Linux  Kernel bugs.

%\lois{This intro section needs work. I'm not happy with what is  here, though I think it is somewhat clearer than what was there before.}

Before a metric can be developed to meet the threat outlined in Section 2, we need to
establish a better understanding of basic kernel behavior, and review what we know about
the risk inherent in privileged code. This section briefly touches on past risk
metrics, as well as the key hypothesis used to guide the capture and evaluation
of kernel traces in our study.

\subsection{Risk Metrics for Identifying Kernel Flaws}

Even though there is no widely accepted method for
quantifying the safety (or risk) of privileged code, there have been a number of
attempts to measure flaws in both software and operating systems. In this section,
we briefly summarize a few of these approaches. Additional information on
past studies of potential flaws.

%\cappos{Is this really true?  No one has ever proposed a metric?  We do need to do a more detailed analysis of this.
%I would vote to remove this sentence regardless...} \lois{ I would agree its probably best just to get rid of the sentence.
%But I believe the goal here was to say that there is no widely accepted and used standard method.}

One study of the Linux kernel \cite{PittSFIeld} suggested that certain parts of the kernel
were more vulnerable than others. Chou et al. demonstrated that some function
directories, i.e., \texttt{drivers},
lead to higher error rates in some parts of the kernel than in
others. The study also suggested that he size of kernel source code and the
maturity of a release also affect how frequently errors occur in the kernel.
Other work has generated vulnerability
signatures~\cite{brumley2006towards}, which match all exploits
of a given flaw. Most of this work is based on a mix of static and
dynamic analysis, constraint solving and symbolic execution~\cite{chou2003static}.

Other researchers have attempted to study the lifecycle of vulnerabilities—when they are
initiated and how long they last. Ozment and Schechter, who studied
vulnerabilities in the code base of an OpenBSD
operating system, determined that a significant extent (61%) of the reported
vulnerabilities were "foundational," meaning they were introduced prior to the
initial version studied. They also reported these vulnerabilities
have a median lifetime of at least 2.6 years.

These past methods can provide some insight on where bugs may lie in kernel and when
they may develop. However, most have relied on statistical methods, such as
negative binomial regression model~\cite{Bug-Location}. The metric we set out to
develop was to be based on empirical study of
the most critical bugs. This ad-hoc security metric can be used for
quantitative measurement and evaluation of the kernel bugs,
and other vulnerabilities at the level of lines of code by checking against
known kernel bugs.

We believe this metric will provide better understanding of kernel security.
As a result, a secure interface with an isolation mindset can be designed
to be exposed to the userspace.

%, they have limitations. Firstly, the metrics mentioned above are not specifically designed for studying bugs in OS kernels
%\cappos{Why does this matter?}

%Therefore, they do not take into account the way system calls are invoked by user applications.
%Moreover, these metrics can not provide information about the accurate location of the bugs within the kernel,
%which is important to our study.
%\cappos{Are you going to show that this is true?  Can you explain more about why these do not work?}
%\cappos{Do existing metrics work on a LOC level?  }

%Without any guidance as to what parts of the kernel are safe, past initiatives to protect the system through isolation,
%such as by building a sandbox or using library OSes, because they could not isolate user programs effectively.
%\cappos{What are you saying?} These methods can mitigate the problem, but any such system will still allow access to the kernel the same way as before.
%They simply move the attack surface from between the user space and the kernel, \yanyan{what's the purpose/consequence of this move?
%why is this move good or bad?} to between these new systems and the kernel, but the surface is not necessarily reduced.
%As a result, the proposed solutions do not make the systems more secure.

%Recognizing this limitation, we propose a novel security metric to
%\lois{does the metric itself tell us HOW to safely-reimplment? Or just tell us whether it needs this reimplementation?}

%\yanyan{I don't think the new metric alerts us tho. maybe say it provides
%as a guidance which parts are risky?} \cappos{end of text}


\subsection{Key Hypothesis}

Our metric development begins with the positing of a hypothesis
that kernel paths executed by popular applications, such as Web browsers or
text editors, are likely to contain fewer exploitable bugs than uncommonly used paths.
As they are frequently used, bugs and vulnerabilities in these common kernel
paths are more likely to have been caught by developers.

In putting forth this hypothesis, we narrow our ``common paths" definition
to also exclude widely used system calls if they include rare arguments
and flags. The proposed metric also excludes odd execution paths through popular
system calls.

\subsection{Foundation for the Metric: Capturing and Evaluating Kernel Traces}

The first step in proving our hypothesis was to capture the lines of kernel
code executed when running applications. The OS kernel code
is organized under different kernel directories.
Whenever an application tries to access system resources, such as file
system, I/O and memory, the kernel code under the corresponding paths is executed. Therefore,
its code execution reflects the basic behavior of the kernel, in response
to user application requests. To better understand this, we identified and
captured which lines of code in the kernel
were executed when running a user program, and named them  \textit{kernel traces}.
Because these traces are closely related to the program that generates them, it is
possible to compare different security systems.
To capture the kernel trace, we used \texttt{gcov} \cite{gcov}, a program profiling
tool that is a standard utility with the GNU compiler collection
%(GCC) suite.

The second step was to evaluate security aspects of the captured kernel traces,% that we captured.
using historical kernel vulnerability reports. We collected a list of
severe kernel bugs from the National Vulnerability Database, the U.S. government repository of
standards-based vulnerability management data \cite{NVD}. For each bug, we
identified which lines of code
in the kernel would trigger it by examining the Linux kernel source code
added as a patch to address a particular bug. From the patch,
we were able to identify \textit{which lines of kernel code need to be modified in order to
remove the bug}.
A user program that executes the lines of code changed by such a patch
is considered to have the \textit{potential to exploit that flaw}.

We determined that any lines of code in the kernel would be considered risky
if they triggered one or more vulnerability. Other lines of code
that did not trigger a vulnerability would be considered to be safe to access.
These lines of code would then compose the common (or safe) portion of the kernel,
which can be trusted to build a secure trusted computing base for secure systems.

\subsection{Verification of Hypothesis}
\label{Verification-of-Hypothesis}

To test the hypothesis that commonly used kernel paths contain fewer bugs, we needed
to identify these paths as a subset of the total reachable kernel paths. 

\textbf{Commonly Used Kernel Paths}
To capture the commonly used kernel paths, we
capture and analyze kernel traces generated while running widely-used
applications or open source libraries, including two large-scale browsers
(Mozilla Firefox and Google Chrome)over \texttt{gcov}. Other experiments
included running 50 packages among the top 200 popular Debian packages \cite{Top-Packages}
in a Linux kernel version 3.14.1.

Several other operations needed to access common paths were conducted, including
intensive file management tasks to create/read/update or delete files and
directories from the underlying filesystem. These tests were completed
during a discrete period of 20 hours over 5 days.

\textbf{Total Reachable Kernel Paths}
The next step was to obtain the total reachable paths and then analyze the location of
any vulnerabilities. To accomplish this, we conducted two separate operations.

%\begin{enumerate}
%During this step, we conducted

\textit{System Call Fuzzing}
System call fuzzing experiments were designed to utilize the Trinity
system call fuzz tester \cite{Trinity}. These included sequential execution of
more than 300 system calls with 1 million iterations
for executing each system call by 16 child processes (Trinity workers).
The obtained kernel trace comprehensively reflected various aspects of the
kernel functionalities.

\textit{Linux Test Project}
Linux Test Project (LTP) \cite{LTP} is another tool to generate the kernel traces
for running all the available system call in different scenarios.
By using LTP we could validate the kernel traces that
were generated by Trinity or catch the possible traces that were missing.

\textbf{CVE Bug Reports}
The last test needed to verify our hypothesis was to check which portions of
the kernel contained bugs. This was accomplished done by comparing the kernel
traces with the lines of code we labeled for each bug, based on change of lines in the
kernel patch. We examined 40 severe Linux kernel
bugs that had been discovered by the research community in the last five
years (represented by the first two columns in Table
\ref{table:vulnerabilities_commonly_used_kernel_paths}).
The bugs chosen from the NVD bug database have the highest severity score.

\subsubsection{Results and Evaluation}
The results show that 38.5\% of the total reachable kernel paths are commonly
used. More importantly, only 2.5\% of the total studied bugs had traces
in the common paths, while 50\% of the bugs resided in the total reachable
kernel paths, which is an indication fewer bugs reside in common paths
compared to uncommon paths. The kernel trace coverage of the common paths and
the total reachable paths are shown in Figure \ref{fig:coverage}.
The results show that the size of commonly-used kernel paths is small,
merely 12.4\% of the entire kernel code base.
The common paths coverage is also significantly smaller than
the total reachable paths coverage (about 1/3 of the entire kernel).

By combining the kernel traces generated by both Trinity and LTP, we were able
to assess the total reachable kernel paths. LTP captured approximately 20\% of kernel
traces that were missed by Trinity, while Trinity
provided about 15\% of kernel trace that were not included by LTP.

Figure \ref{fig:datacollection} shows different tools and platforms that were used 
for the analysis.

The results from Figure \ref{fig:subset} and Figure \ref{fig:key_paths_trace}
show that the common paths are a subset of the
total reachable paths.

In terms of where the bugs were located, our data suggests that
commonly used kernel paths
contain only 2.5\% of all the bugs that we studied.
Since the total reachable kernel paths contain 50\% of the bugs that were
examined in this paper, we can conclude
that commonly used kernel paths clearly contain fewer bugs than other
portions of the kernel.

The results of our experiment are shown in the last two columns in 
Table \ref{table:vulnerabilities_commonly_used_kernel_paths}.

\begin{table*}[!ht]
\scriptsize
\centering

\caption {Linux Kernel Bugs, and Vulnerabilities in Different Portions of
the Kernel
({\color{red}\ding{51}}: vulnerability in paths; \ding{55}: vulnerability
not in paths)}

\begin{tabular}{|l|l|c|c|}\hline
\multirow{2}{*}{\textbf{Vulnerability}} & \multirow{2}{*}{\textbf{Specific
Type}} & \multicolumn{2}{c|}{\bf Portion of the Kernel} \\
\cline{3-4}
&  & \textbf{Total Reachable Paths} &  \textbf{Common Paths} \\ \hline

 CVE-2014-9529 & concurrency, race condition & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2014-3631 & NULL pointer dereference & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2012-6657 & network socket variable mischeck & {\color{red}\ding{51}}
& \ding{55} \\
 CVE-2014-5207 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-5206 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-3153 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-2851 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-2706 & race condition, DoS & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2014-0100 & race condition, DoS & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2014-0049 & buffer overflow & \ding{55} & \ding{55} \\
 CVE-2012-6638 & DoS & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2014-0038 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-6368 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-4587 & index error, privilege escalation & \ding{55} & \ding{55}
\\
 CVE-2013-4563 & size/boundary check, DoS & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2013-4348 & value validation error & \ding{55} & \ding{55} \\
 CVE-2013-4300 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-1943 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-2094 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-3301 & NULL pointer dereference, DoS & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2013-1858 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-1797 & use-after-free & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2013-1763 & privilege escalation, index error & \ding{55} & \ding{55}
\\
 CVE-2013-0310 & NULL pointer dereference & \ding{55} & \ding{55} \\
 CVE-2012-2136 & heap-based buffer overflow & \ding{55} & \ding{55} \\
 CVE-2012-2100 & lack of sanity check  & \ding{55} & \ding{55} \\
 CVE-2012-0028 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2011-2517 & privilege escalation, buffer overflow &
{\color{red}\ding{51}} & \ding{55} \\
 CVE-2012-2123 & privilege escalation  & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2012-1146 & NULL pointer dereference  & \ding{55} & \ding{55} \\
 CVE-2012-0207 & divide-by-zero error and panic & \ding{55} & \ding{55} \\
 CVE-2011-2525 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2011-1076 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2011-2184 & NULL pointer dereference, none initialization & \ding{55}
& \ding{55} \\
 CVE-2010-2478 & integer overflow & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2010-2960 & NULL pointer dereference  & \ding{55} & \ding{55} \\
 CVE-2010-2492 & privilege escalation, buffer overflow & \ding{55} &
\ding{55} \\
 CVE-2010-2240 & stack overflow & {\color{red}\ding{51}} &
{\color{red}\ding{51}}\\
 CVE-2010-1188 & use-after-free & \ding{55} & \ding{55} \\
 CVE-2010-0437 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\ \hline
 \multicolumn{2}{|c|}{\bf Percentage contains bugs} & {\bf $50\%$} & {\bf
$2.5\%$} \\ \hline
\end{tabular}
\label{table:vulnerabilities_commonly_used_kernel_paths}
\end{table*}


\begin{figure}%[h]
\centering
\includegraphics[width=1.0\columnwidth]{diagram/data_collection.png}
\caption{Various activities performed to capture and analyze the kernel
 traces generated by legacy applications, system fuzzers, LTP, and CVE bug
 reports. The traces are collected using \texttt{gcov} and a Python-based
 program that transforms the gcov data to
 macrodata-level information of each traversed path for final data analysis.}
 %\lois{transformed to what? And, how?

\label{fig:datacollection}
\end{figure}

%\yanyan{I feel this is a bit early to make this conclusion.}
%\lois{does the slight wording change answer your concern, Yanyan?}


\begin{figure}%[h]
\centering
\includegraphics[width=1.0\columnwidth]{diagram/kernelcoverage.png}
\caption{Percentage of different kernel areas that were reached during
 LTP and Trinity system call fuzzing experiments.
 \yiwen{This figure will be replaced. I am working on a new one that will show 
 where different bugs are located.}}
\label{fig:coverage}
\end{figure}


%Although the total reachable paths coverage is not 100\% of the entire
%kernel code base,
%it is still very large and contains many bugs.
%However, because the commonly used kernel path coverage is much smaller
%than
%the total reachable path coverage, this is a positive indication that these
%relatively small areas can be considered safe.

%\begin{table}
%\centering
%\scriptsize
%\caption {Kernel Coverage}
%\begin{tabular}{|l|c|}
%  \hline
%  \textbf{Kernel Paths} & \textbf{Kernel Coverage (percentage)} \\
%  \hline \hline
%  Common Paths & 12.4\% \\
%  \hline
%  Total Reachable Paths & 32.2\% \\
%  \hline
%\end{tabular}
%\label{table:kernel_coverage}
%\end{table}

\begin{figure}
	\centering
	\includegraphics[width=1.0\columnwidth]{diagram/lind_oakland16_diagram_01.pdf}
	\caption{Kernel Trace Comparison: Common paths as a subset of reachable paths}
	\label{fig:subset}
	\end{figure}

	\begin{figure}
	\centering
	\includegraphics[width=1.0\columnwidth]{diagram/lind_oakland16_diagram_02.pdf}
	\caption{Kernel Trace in Key Paths}
	\label{fig:key_paths_trace}
\end{figure}


\begin{table*}[!ht]
\scriptsize
\centering

\caption {Linux Kernel Bugs, and Vulnerabilities in Different Portions of
the Kernel
({\color{red}\ding{51}}: vulnerability in paths; \ding{55}: vulnerability
not in paths)}

\begin{tabular}{|l|l|c|c|}\hline
\multirow{2}{*}{\textbf{Vulnerability}} & \multirow{2}{*}{\textbf{Specific
Type}} & \multicolumn{2}{c|}{\bf Portion of the Kernel} \\
\cline{3-4}
&  & \textbf{Total Reachable Paths} &  \textbf{Common Paths} \\ \hline

 CVE-2014-9529 & concurrency, race condition & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2014-3631 & NULL pointer dereference & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2012-6657 & network socket variable mischeck & {\color{red}\ding{51}}
& \ding{55} \\
 CVE-2014-5207 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-5206 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-3153 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-2851 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2014-2706 & race condition, DoS & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2014-0100 & race condition, DoS & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2014-0049 & buffer overflow & \ding{55} & \ding{55} \\
 CVE-2012-6638 & DoS & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2014-0038 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-6368 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-4587 & index error, privilege escalation & \ding{55} & \ding{55}
\\
 CVE-2013-4563 & size/boundary check, DoS & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2013-4348 & value validation error & \ding{55} & \ding{55} \\
 CVE-2013-4300 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-1943 & privilege escalation & \ding{55} & \ding{55} \\
 CVE-2013-2094 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-3301 & NULL pointer dereference, DoS & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2013-1858 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2013-1797 & use-after-free & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2013-1763 & privilege escalation, index error & \ding{55} & \ding{55}
\\
 CVE-2013-0310 & NULL pointer dereference & \ding{55} & \ding{55} \\
 CVE-2012-2136 & heap-based buffer overflow & \ding{55} & \ding{55} \\
 CVE-2012-2100 & lack of sanity check  & \ding{55} & \ding{55} \\
 CVE-2012-0028 & privilege escalation & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2011-2517 & privilege escalation, buffer overflow &
{\color{red}\ding{51}} & \ding{55} \\
 CVE-2012-2123 & privilege escalation  & {\color{red}\ding{51}} & \ding{55}
\\
 CVE-2012-1146 & NULL pointer dereference  & \ding{55} & \ding{55} \\
 CVE-2012-0207 & divide-by-zero error and panic & \ding{55} & \ding{55} \\
 CVE-2011-2525 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2011-1076 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\
 CVE-2011-2184 & NULL pointer dereference, none initialization & \ding{55}
& \ding{55} \\
 CVE-2010-2478 & integer overflow & {\color{red}\ding{51}} & \ding{55} \\
 CVE-2010-2960 & NULL pointer dereference  & \ding{55} & \ding{55} \\
 CVE-2010-2492 & privilege escalation, buffer overflow & \ding{55} &
\ding{55} \\
 CVE-2010-2240 & stack overflow & {\color{red}\ding{51}} &
{\color{red}\ding{51}}\\
 CVE-2010-1188 & use-after-free & \ding{55} & \ding{55} \\
 CVE-2010-0437 & NULL pointer dereference  & {\color{red}\ding{51}} &
\ding{55} \\ \hline
 \multicolumn{2}{|c|}{\bf Percentage contains bugs} & {\bf $50\%$} & {\bf
$2.5\%$} \\ \hline
\end{tabular}
\label{table:vulnerabilities_commonly_used_kernel_paths}
\end{table*}

%We studied bugs from the large-scale NVD database which includes representative bugs for all categories,
%and conducted experiments with ones with the highest vulnerability severity scores. This makes it a fair collection of available bugs sample
%to ensure the sample was not biased and it would be a normal distribution of bugs in the Linux kernel.
%\lois{Why does thismethod, which seems less than random, prove it is not biased?}


%Our hypothesis and findings provide insights and guidelines for new designs of secure systems, which will be discussed in the next section.
%\cappos{Is this statistically significant?}
%\yiwen{I added something to explain our bug sample dataset. More knowledge of statistics may be required. I will think about it more.}